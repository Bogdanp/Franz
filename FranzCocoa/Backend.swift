// This file was automatically generated by noise-serde-lib.
import Foundation
import NoiseBackend
import NoiseSerde

public enum AuthMechanism: Readable, Writable {
  case plain
  case scramSHA256
  case scramSHA512
  case aws

  public static func read(from inp: InputPort, using buf: inout Data) -> AuthMechanism {
    let tag = UVarint.read(from: inp, using: &buf)
    switch tag {
    case 0x0000:
      return .plain
    case 0x0001:
      return .scramSHA256
    case 0x0002:
      return .scramSHA512
    case 0x0003:
      return .aws
    default:
      preconditionFailure("AuthMechanism: unexpected tag \(tag)")
    }
  }

  public func write(to out: OutputPort) {
    switch self {
    case .plain:
      UVarint(0x0000).write(to: out)
    case .scramSHA256:
      UVarint(0x0001).write(to: out)
    case .scramSHA512:
      UVarint(0x0002).write(to: out)
    case .aws:
      UVarint(0x0003).write(to: out)
    }
  }
}

public enum IteratorOffset: Readable, Writable {
  case earliest
  case latest
  case recent(UVarint)
  case timestamp(UVarint)
  case exact(UVarint)

  public static func read(from inp: InputPort, using buf: inout Data) -> IteratorOffset {
    let tag = UVarint.read(from: inp, using: &buf)
    switch tag {
    case 0x0000:
      return .earliest
    case 0x0001:
      return .latest
    case 0x0002:
      return .recent(
        UVarint.read(from: inp, using: &buf)
      )
    case 0x0003:
      return .timestamp(
        UVarint.read(from: inp, using: &buf)
      )
    case 0x0004:
      return .exact(
        UVarint.read(from: inp, using: &buf)
      )
    default:
      preconditionFailure("IteratorOffset: unexpected tag \(tag)")
    }
  }

  public func write(to out: OutputPort) {
    switch self {
    case .earliest:
      UVarint(0x0000).write(to: out)
    case .latest:
      UVarint(0x0001).write(to: out)
    case .recent(let count):
      UVarint(0x0002).write(to: out)
      count.write(to: out)
    case .timestamp(let timestamp):
      UVarint(0x0003).write(to: out)
      timestamp.write(to: out)
    case .exact(let offset):
      UVarint(0x0004).write(to: out)
      offset.write(to: out)
    }
  }
}

public enum IteratorResult: Readable, Writable {
  case original(IteratorRecord)
  case transformed(IteratorRecord, IteratorRecord)

  public static func read(from inp: InputPort, using buf: inout Data) -> IteratorResult {
    let tag = UVarint.read(from: inp, using: &buf)
    switch tag {
    case 0x0000:
      return .original(
        IteratorRecord.read(from: inp, using: &buf)
      )
    case 0x0001:
      return .transformed(
        IteratorRecord.read(from: inp, using: &buf),
        IteratorRecord.read(from: inp, using: &buf)
      )
    default:
      preconditionFailure("IteratorResult: unexpected tag \(tag)")
    }
  }

  public func write(to out: OutputPort) {
    switch self {
    case .original(let record):
      UVarint(0x0000).write(to: out)
      record.write(to: out)
    case .transformed(let record, let original):
      UVarint(0x0001).write(to: out)
      record.write(to: out)
      original.write(to: out)
    }
  }
}

public enum Lexer: Readable, Writable {
  case json
  case lua
  case protobuf

  public static func read(from inp: InputPort, using buf: inout Data) -> Lexer {
    let tag = UVarint.read(from: inp, using: &buf)
    switch tag {
    case 0x0000:
      return .json
    case 0x0001:
      return .lua
    case 0x0002:
      return .protobuf
    default:
      preconditionFailure("Lexer: unexpected tag \(tag)")
    }
  }

  public func write(to out: OutputPort) {
    switch self {
    case .json:
      UVarint(0x0000).write(to: out)
    case .lua:
      UVarint(0x0001).write(to: out)
    case .protobuf:
      UVarint(0x0002).write(to: out)
    }
  }
}

public enum ReduceResult: Readable, Writable {
  case text(String)
  case number(Float64)
  case barChart(String, [String], String, [Float64])
  case lineChart(String, [Float64], String, [Float64])
  case scatterChart(String, [Float64], String, [Float64])
  case table([String], [TableRow])

  public static func read(from inp: InputPort, using buf: inout Data) -> ReduceResult {
    let tag = UVarint.read(from: inp, using: &buf)
    switch tag {
    case 0x0000:
      return .text(
        String.read(from: inp, using: &buf)
      )
    case 0x0001:
      return .number(
        Float64.read(from: inp, using: &buf)
      )
    case 0x0002:
      return .barChart(
        String.read(from: inp, using: &buf),
        [String].read(from: inp, using: &buf),
        String.read(from: inp, using: &buf),
        [Float64].read(from: inp, using: &buf)
      )
    case 0x0003:
      return .lineChart(
        String.read(from: inp, using: &buf),
        [Float64].read(from: inp, using: &buf),
        String.read(from: inp, using: &buf),
        [Float64].read(from: inp, using: &buf)
      )
    case 0x0004:
      return .scatterChart(
        String.read(from: inp, using: &buf),
        [Float64].read(from: inp, using: &buf),
        String.read(from: inp, using: &buf),
        [Float64].read(from: inp, using: &buf)
      )
    case 0x0005:
      return .table(
        [String].read(from: inp, using: &buf),
        [TableRow].read(from: inp, using: &buf)
      )
    default:
      preconditionFailure("ReduceResult: unexpected tag \(tag)")
    }
  }

  public func write(to out: OutputPort) {
    switch self {
    case .text(let s):
      UVarint(0x0000).write(to: out)
      s.write(to: out)
    case .number(let n):
      UVarint(0x0001).write(to: out)
      n.write(to: out)
    case .barChart(let xlabel, let xs, let ylabel, let ys):
      UVarint(0x0002).write(to: out)
      xlabel.write(to: out)
      xs.write(to: out)
      ylabel.write(to: out)
      ys.write(to: out)
    case .lineChart(let xlabel, let xs, let ylabel, let ys):
      UVarint(0x0003).write(to: out)
      xlabel.write(to: out)
      xs.write(to: out)
      ylabel.write(to: out)
      ys.write(to: out)
    case .scatterChart(let xlabel, let xs, let ylabel, let ys):
      UVarint(0x0004).write(to: out)
      xlabel.write(to: out)
      xs.write(to: out)
      ylabel.write(to: out)
      ys.write(to: out)
    case .table(let columns, let rows):
      UVarint(0x0005).write(to: out)
      columns.write(to: out)
      rows.write(to: out)
    }
  }
}

public enum SchemaRegistryKind: Readable, Writable {
  case confluent

  public static func read(from inp: InputPort, using buf: inout Data) -> SchemaRegistryKind {
    let tag = UVarint.read(from: inp, using: &buf)
    switch tag {
    case 0x0000:
      return .confluent
    default:
      preconditionFailure("SchemaRegistryKind: unexpected tag \(tag)")
    }
  }

  public func write(to out: OutputPort) {
    switch self {
    case .confluent:
      UVarint(0x0000).write(to: out)
    }
  }
}

public enum SchemaType: Readable, Writable {
  case avro
  case json
  case protobuf

  public static func read(from inp: InputPort, using buf: inout Data) -> SchemaType {
    let tag = UVarint.read(from: inp, using: &buf)
    switch tag {
    case 0x0000:
      return .avro
    case 0x0001:
      return .json
    case 0x0002:
      return .protobuf
    default:
      preconditionFailure("SchemaType: unexpected tag \(tag)")
    }
  }

  public func write(to out: OutputPort) {
    switch self {
    case .avro:
      UVarint(0x0000).write(to: out)
    case .json:
      UVarint(0x0001).write(to: out)
    case .protobuf:
      UVarint(0x0002).write(to: out)
    }
  }
}

public enum TokenType: Readable, Writable {
  case whitespace
  case punctuation
  case comment
  case keyword
  case number
  case string
  case name

  public static func read(from inp: InputPort, using buf: inout Data) -> TokenType {
    let tag = UVarint.read(from: inp, using: &buf)
    switch tag {
    case 0x0000:
      return .whitespace
    case 0x0001:
      return .punctuation
    case 0x0002:
      return .comment
    case 0x0003:
      return .keyword
    case 0x0004:
      return .number
    case 0x0005:
      return .string
    case 0x0006:
      return .name
    default:
      preconditionFailure("TokenType: unexpected tag \(tag)")
    }
  }

  public func write(to out: OutputPort) {
    switch self {
    case .whitespace:
      UVarint(0x0000).write(to: out)
    case .punctuation:
      UVarint(0x0001).write(to: out)
    case .comment:
      UVarint(0x0002).write(to: out)
    case .keyword:
      UVarint(0x0003).write(to: out)
    case .number:
      UVarint(0x0004).write(to: out)
    case .string:
      UVarint(0x0005).write(to: out)
    case .name:
      UVarint(0x0006).write(to: out)
    }
  }
}

public struct ApplyResult: Readable, Writable {
  public let items: [IteratorResult]
  public let output: Data
  public let reduced: ReduceResult?

  public init(
    items: [IteratorResult],
    output: Data,
    reduced: ReduceResult?
  ) {
    self.items = items
    self.output = output
    self.reduced = reduced
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> ApplyResult {
    return ApplyResult(
      items: [IteratorResult].read(from: inp, using: &buf),
      output: Data.read(from: inp, using: &buf),
      reduced: ReduceResult?.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    items.write(to: out)
    output.write(to: out)
    reduced.write(to: out)
  }
}

public struct Broker: Readable, Writable {
  public let id: UVarint
  public let host: String
  public let port: UVarint
  public let rack: String?
  public let isController: Bool

  public init(
    id: UVarint,
    host: String,
    port: UVarint,
    rack: String?,
    isController: Bool
  ) {
    self.id = id
    self.host = host
    self.port = port
    self.rack = rack
    self.isController = isController
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> Broker {
    return Broker(
      id: UVarint.read(from: inp, using: &buf),
      host: String.read(from: inp, using: &buf),
      port: UVarint.read(from: inp, using: &buf),
      rack: String?.read(from: inp, using: &buf),
      isController: Bool.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    id.write(to: out)
    host.write(to: out)
    port.write(to: out)
    rack.write(to: out)
    isController.write(to: out)
  }
}

public struct ConnectionDetails: Readable, Writable {
  public let id: UVarint?
  public let name: String
  public let httpProxyAddr: String?
  public let bootstrapHost: String
  public let bootstrapPort: UVarint
  public let authMechanism: AuthMechanism
  public let username: String?
  public let password: String?
  public let passwordId: String?
  public let awsRegion: String?
  public let awsAccessKeyId: String?
  public let useSsl: Bool
  public var sslKeyPath: String?
  public var sslCertPath: String?
  public var schemaRegistryId: UVarint?

  public init(
    id: UVarint?,
    name: String,
    httpProxyAddr: String?,
    bootstrapHost: String,
    bootstrapPort: UVarint,
    authMechanism: AuthMechanism,
    username: String?,
    password: String?,
    passwordId: String?,
    awsRegion: String?,
    awsAccessKeyId: String?,
    useSsl: Bool,
    sslKeyPath: String?,
    sslCertPath: String?,
    schemaRegistryId: UVarint?
  ) {
    self.id = id
    self.name = name
    self.httpProxyAddr = httpProxyAddr
    self.bootstrapHost = bootstrapHost
    self.bootstrapPort = bootstrapPort
    self.authMechanism = authMechanism
    self.username = username
    self.password = password
    self.passwordId = passwordId
    self.awsRegion = awsRegion
    self.awsAccessKeyId = awsAccessKeyId
    self.useSsl = useSsl
    self.sslKeyPath = sslKeyPath
    self.sslCertPath = sslCertPath
    self.schemaRegistryId = schemaRegistryId
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> ConnectionDetails {
    return ConnectionDetails(
      id: UVarint?.read(from: inp, using: &buf),
      name: String.read(from: inp, using: &buf),
      httpProxyAddr: String?.read(from: inp, using: &buf),
      bootstrapHost: String.read(from: inp, using: &buf),
      bootstrapPort: UVarint.read(from: inp, using: &buf),
      authMechanism: AuthMechanism.read(from: inp, using: &buf),
      username: String?.read(from: inp, using: &buf),
      password: String?.read(from: inp, using: &buf),
      passwordId: String?.read(from: inp, using: &buf),
      awsRegion: String?.read(from: inp, using: &buf),
      awsAccessKeyId: String?.read(from: inp, using: &buf),
      useSsl: Bool.read(from: inp, using: &buf),
      sslKeyPath: String?.read(from: inp, using: &buf),
      sslCertPath: String?.read(from: inp, using: &buf),
      schemaRegistryId: UVarint?.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    id.write(to: out)
    name.write(to: out)
    httpProxyAddr.write(to: out)
    bootstrapHost.write(to: out)
    bootstrapPort.write(to: out)
    authMechanism.write(to: out)
    username.write(to: out)
    password.write(to: out)
    passwordId.write(to: out)
    awsRegion.write(to: out)
    awsAccessKeyId.write(to: out)
    useSsl.write(to: out)
    sslKeyPath.write(to: out)
    sslCertPath.write(to: out)
    schemaRegistryId.write(to: out)
  }
}

public struct Group: Readable, Writable {
  public let id: String
  public let stats: Stats

  public init(
    id: String,
    stats: Stats
  ) {
    self.id = id
    self.stats = stats
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> Group {
    return Group(
      id: String.read(from: inp, using: &buf),
      stats: Stats.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    id.write(to: out)
    stats.write(to: out)
  }
}

public struct GroupOffsets: Readable, Writable {
  public let groupId: String
  public let topics: [GroupTopic]
  public let state: Symbol

  public init(
    groupId: String,
    topics: [GroupTopic],
    state: Symbol
  ) {
    self.groupId = groupId
    self.topics = topics
    self.state = state
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> GroupOffsets {
    return GroupOffsets(
      groupId: String.read(from: inp, using: &buf),
      topics: [GroupTopic].read(from: inp, using: &buf),
      state: Symbol.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    groupId.write(to: out)
    topics.write(to: out)
    state.write(to: out)
  }
}

public struct GroupPartitionOffset: Readable, Writable {
  public let partitionId: UVarint
  public let highWatermark: Varint
  public let offset: Varint
  public let memberId: String?
  public let clientId: String?
  public let clientHost: String?

  public init(
    partitionId: UVarint,
    highWatermark: Varint,
    offset: Varint,
    memberId: String?,
    clientId: String?,
    clientHost: String?
  ) {
    self.partitionId = partitionId
    self.highWatermark = highWatermark
    self.offset = offset
    self.memberId = memberId
    self.clientId = clientId
    self.clientHost = clientHost
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> GroupPartitionOffset {
    return GroupPartitionOffset(
      partitionId: UVarint.read(from: inp, using: &buf),
      highWatermark: Varint.read(from: inp, using: &buf),
      offset: Varint.read(from: inp, using: &buf),
      memberId: String?.read(from: inp, using: &buf),
      clientId: String?.read(from: inp, using: &buf),
      clientHost: String?.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    partitionId.write(to: out)
    highWatermark.write(to: out)
    offset.write(to: out)
    memberId.write(to: out)
    clientId.write(to: out)
    clientHost.write(to: out)
  }
}

public struct GroupTopic: Readable, Writable {
  public let name: String
  public let partitions: [GroupPartitionOffset]

  public init(
    name: String,
    partitions: [GroupPartitionOffset]
  ) {
    self.name = name
    self.partitions = partitions
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> GroupTopic {
    return GroupTopic(
      name: String.read(from: inp, using: &buf),
      partitions: [GroupPartitionOffset].read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    name.write(to: out)
    partitions.write(to: out)
  }
}

public struct IteratorRecord: Readable, Writable {
  public let partitionId: UVarint
  public let offset: UVarint
  public let timestamp: UVarint
  public let key: Data?
  public let value: Data?
  public let headers: [String: Data]

  public init(
    partitionId: UVarint,
    offset: UVarint,
    timestamp: UVarint,
    key: Data?,
    value: Data?,
    headers: [String: Data]
  ) {
    self.partitionId = partitionId
    self.offset = offset
    self.timestamp = timestamp
    self.key = key
    self.value = value
    self.headers = headers
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> IteratorRecord {
    return IteratorRecord(
      partitionId: UVarint.read(from: inp, using: &buf),
      offset: UVarint.read(from: inp, using: &buf),
      timestamp: UVarint.read(from: inp, using: &buf),
      key: Data?.read(from: inp, using: &buf),
      value: Data?.read(from: inp, using: &buf),
      headers: [String: Data].read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    partitionId.write(to: out)
    offset.write(to: out)
    timestamp.write(to: out)
    key.write(to: out)
    value.write(to: out)
    headers.write(to: out)
  }
}

public struct Metadata: Readable, Writable {
  public let brokers: [Broker]
  public let topics: [Topic]
  public let groups: [Group]
  public let schemas: [Schema]

  public init(
    brokers: [Broker],
    topics: [Topic],
    groups: [Group],
    schemas: [Schema]
  ) {
    self.brokers = brokers
    self.topics = topics
    self.groups = groups
    self.schemas = schemas
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> Metadata {
    return Metadata(
      brokers: [Broker].read(from: inp, using: &buf),
      topics: [Topic].read(from: inp, using: &buf),
      groups: [Group].read(from: inp, using: &buf),
      schemas: [Schema].read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    brokers.write(to: out)
    topics.write(to: out)
    groups.write(to: out)
    schemas.write(to: out)
  }
}

public struct Release: Readable, Writable {
  public let arch: Symbol
  public let version: String
  public let macUrl: String?
  public let linuxUrl: String?
  public let windowsUrl: String?

  public init(
    arch: Symbol,
    version: String,
    macUrl: String?,
    linuxUrl: String?,
    windowsUrl: String?
  ) {
    self.arch = arch
    self.version = version
    self.macUrl = macUrl
    self.linuxUrl = linuxUrl
    self.windowsUrl = windowsUrl
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> Release {
    return Release(
      arch: Symbol.read(from: inp, using: &buf),
      version: String.read(from: inp, using: &buf),
      macUrl: String?.read(from: inp, using: &buf),
      linuxUrl: String?.read(from: inp, using: &buf),
      windowsUrl: String?.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    arch.write(to: out)
    version.write(to: out)
    macUrl.write(to: out)
    linuxUrl.write(to: out)
    windowsUrl.write(to: out)
  }
}

public struct ResourceConfig: Readable, Writable {
  public let name: String
  public let value: String?
  public let isReadOnly: Bool
  public let isDefault: Bool
  public let isSensitive: Bool
  public let docUrl: String?

  public init(
    name: String,
    value: String?,
    isReadOnly: Bool,
    isDefault: Bool,
    isSensitive: Bool,
    docUrl: String?
  ) {
    self.name = name
    self.value = value
    self.isReadOnly = isReadOnly
    self.isDefault = isDefault
    self.isSensitive = isSensitive
    self.docUrl = docUrl
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> ResourceConfig {
    return ResourceConfig(
      name: String.read(from: inp, using: &buf),
      value: String?.read(from: inp, using: &buf),
      isReadOnly: Bool.read(from: inp, using: &buf),
      isDefault: Bool.read(from: inp, using: &buf),
      isSensitive: Bool.read(from: inp, using: &buf),
      docUrl: String?.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    name.write(to: out)
    value.write(to: out)
    isReadOnly.write(to: out)
    isDefault.write(to: out)
    isSensitive.write(to: out)
    docUrl.write(to: out)
  }
}

public struct Schema: Readable, Writable {
  public let id: UVarint?
  public let name: String
  public let type: SchemaType?
  public let version: UVarint?
  public let schema: String?

  public init(
    id: UVarint?,
    name: String,
    type: SchemaType?,
    version: UVarint?,
    schema: String?
  ) {
    self.id = id
    self.name = name
    self.type = type
    self.version = version
    self.schema = schema
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> Schema {
    return Schema(
      id: UVarint?.read(from: inp, using: &buf),
      name: String.read(from: inp, using: &buf),
      type: SchemaType?.read(from: inp, using: &buf),
      version: UVarint?.read(from: inp, using: &buf),
      schema: String?.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    id.write(to: out)
    name.write(to: out)
    type.write(to: out)
    version.write(to: out)
    schema.write(to: out)
  }
}

public struct SchemaRegistry: Readable, Writable {
  public let id: UVarint?
  public let kind: SchemaRegistryKind
  public let url: String
  public let username: String?
  public let passwordId: String?

  public init(
    id: UVarint?,
    kind: SchemaRegistryKind,
    url: String,
    username: String?,
    passwordId: String?
  ) {
    self.id = id
    self.kind = kind
    self.url = url
    self.username = username
    self.passwordId = passwordId
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> SchemaRegistry {
    return SchemaRegistry(
      id: UVarint?.read(from: inp, using: &buf),
      kind: SchemaRegistryKind.read(from: inp, using: &buf),
      url: String.read(from: inp, using: &buf),
      username: String?.read(from: inp, using: &buf),
      passwordId: String?.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    id.write(to: out)
    kind.write(to: out)
    url.write(to: out)
    username.write(to: out)
    passwordId.write(to: out)
  }
}

public struct Stats: Readable, Writable {
  public let minLag: Varint
  public let maxLag: Varint
  public let sumLag: Varint

  public init(
    minLag: Varint,
    maxLag: Varint,
    sumLag: Varint
  ) {
    self.minLag = minLag
    self.maxLag = maxLag
    self.sumLag = sumLag
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> Stats {
    return Stats(
      minLag: Varint.read(from: inp, using: &buf),
      maxLag: Varint.read(from: inp, using: &buf),
      sumLag: Varint.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    minLag.write(to: out)
    maxLag.write(to: out)
    sumLag.write(to: out)
  }
}

public struct TableRow: Readable, Writable {
  public let columns: [String]

  public init(
    columns: [String]
  ) {
    self.columns = columns
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> TableRow {
    return TableRow(
      columns: [String].read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    columns.write(to: out)
  }
}

public struct Token: Readable, Writable {
  public let type: TokenType
  public let span: TokenSpan

  public init(
    type: TokenType,
    span: TokenSpan
  ) {
    self.type = type
    self.span = span
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> Token {
    return Token(
      type: TokenType.read(from: inp, using: &buf),
      span: TokenSpan.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    type.write(to: out)
    span.write(to: out)
  }
}

public struct TokenSpan: Readable, Writable {
  public let pos: UVarint
  public let len: UVarint

  public init(
    pos: UVarint,
    len: UVarint
  ) {
    self.pos = pos
    self.len = len
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> TokenSpan {
    return TokenSpan(
      pos: UVarint.read(from: inp, using: &buf),
      len: UVarint.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    pos.write(to: out)
    len.write(to: out)
  }
}

public struct Topic: Readable, Writable {
  public let name: String
  public let partitions: [TopicPartition]
  public let isInternal: Bool
  public let stats: Stats

  public init(
    name: String,
    partitions: [TopicPartition],
    isInternal: Bool,
    stats: Stats
  ) {
    self.name = name
    self.partitions = partitions
    self.isInternal = isInternal
    self.stats = stats
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> Topic {
    return Topic(
      name: String.read(from: inp, using: &buf),
      partitions: [TopicPartition].read(from: inp, using: &buf),
      isInternal: Bool.read(from: inp, using: &buf),
      stats: Stats.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    name.write(to: out)
    partitions.write(to: out)
    isInternal.write(to: out)
    stats.write(to: out)
  }
}

public struct TopicOption: Readable, Writable {
  public let key: String
  public let value: String

  public init(
    key: String,
    value: String
  ) {
    self.key = key
    self.value = value
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> TopicOption {
    return TopicOption(
      key: String.read(from: inp, using: &buf),
      value: String.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    key.write(to: out)
    value.write(to: out)
  }
}

public struct TopicPartition: Readable, Writable {
  public let id: UVarint
  public let leaderId: Varint
  public let replicaNodeIds: [UVarint]
  public let inSyncReplicaNodeIds: [UVarint]

  public init(
    id: UVarint,
    leaderId: Varint,
    replicaNodeIds: [UVarint],
    inSyncReplicaNodeIds: [UVarint]
  ) {
    self.id = id
    self.leaderId = leaderId
    self.replicaNodeIds = replicaNodeIds
    self.inSyncReplicaNodeIds = inSyncReplicaNodeIds
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> TopicPartition {
    return TopicPartition(
      id: UVarint.read(from: inp, using: &buf),
      leaderId: Varint.read(from: inp, using: &buf),
      replicaNodeIds: [UVarint].read(from: inp, using: &buf),
      inSyncReplicaNodeIds: [UVarint].read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    id.write(to: out)
    leaderId.write(to: out)
    replicaNodeIds.write(to: out)
    inSyncReplicaNodeIds.write(to: out)
  }
}

public struct UpdateAvailable: Readable, Writable {
  public let changelog: String
  public let release: Release

  public init(
    changelog: String,
    release: Release
  ) {
    self.changelog = changelog
    self.release = release
  }

  public static func read(from inp: InputPort, using buf: inout Data) -> UpdateAvailable {
    return UpdateAvailable(
      changelog: String.read(from: inp, using: &buf),
      release: Release.read(from: inp, using: &buf)
    )
  }

  public func write(to out: OutputPort) {
    changelog.write(to: out)
    release.write(to: out)
  }
}

public class Backend {
  let impl: NoiseBackend.Backend!

  init(withZo zo: URL, andMod mod: String, andProc proc: String) {
    impl = NoiseBackend.Backend(withZo: zo, andMod: mod, andProc: proc)
  }

  public func activateLicense(_ key: String) -> Future<String, Bool> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0000).write(to: out)
        key.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Bool in
        return Bool.read(from: inp, using: &buf)
      }
    )
  }

  public func activateSchemaRegistry(_ r: SchemaRegistry, withPassword password: String?, inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0001).write(to: out)
        r.write(to: out)
        password.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func activateScript(_ script: String, forTopic topic: String, inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0002).write(to: out)
        script.write(to: out)
        topic.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func applyScript(_ script: String, toRecords records: [IteratorRecord], inWorkspace id: UVarint) -> Future<String, ApplyResult> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0003).write(to: out)
        script.write(to: out)
        records.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> ApplyResult in
        return ApplyResult.read(from: inp, using: &buf)
      }
    )
  }

  public func checkForUpdates() -> Future<String, UpdateAvailable?> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0004).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> UpdateAvailable? in
        return UpdateAvailable?.read(from: inp, using: &buf)
      }
    )
  }

  public func closeAllWorkspaces() -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0005).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func closeIterator(withId id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0006).write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func closeWorkspace(_ id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0007).write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func createTopic(named name: String, withPartitions partitions: UVarint, andReplicationFactor replicationFactor: UVarint, andOptions options: [TopicOption], inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0008).write(to: out)
        name.write(to: out)
        partitions.write(to: out)
        replicationFactor.write(to: out)
        options.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func deactivateSchemaRegistry(inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0009).write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func deactivateScript(forTopic topic: String, inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x000a).write(to: out)
        topic.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func deleteConnection(_ c: ConnectionDetails) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x000b).write(to: out)
        c.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func deleteGroup(named groupId: String, inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x000c).write(to: out)
        groupId.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func deleteSchemaRegistry(_ id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x000d).write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func deleteTopic(named name: String, inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x000e).write(to: out)
        name.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func fetchOffsets(forGroupNamed groupId: String, inWorkspace id: UVarint) -> Future<String, GroupOffsets> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x000f).write(to: out)
        groupId.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> GroupOffsets in
        return GroupOffsets.read(from: inp, using: &buf)
      }
    )
  }

  public func fetchRelease(release r: Release) -> Future<String, String> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0010).write(to: out)
        r.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> String in
        return String.read(from: inp, using: &buf)
      }
    )
  }

  public func findTopicGroups(forTopic topic: String, inWorkspace id: UVarint) -> Future<String, [String]> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0011).write(to: out)
        topic.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> [String] in
        return [String].read(from: inp, using: &buf)
      }
    )
  }

  public func generatePasswordId() -> Future<String, String> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0012).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> String in
        return String.read(from: inp, using: &buf)
      }
    )
  }

  public func getChangelog() -> Future<String, String> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0013).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> String in
        return String.read(from: inp, using: &buf)
      }
    )
  }

  public func getConnection(_ id: UVarint) -> Future<String, ConnectionDetails?> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0014).write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> ConnectionDetails? in
        return ConnectionDetails?.read(from: inp, using: &buf)
      }
    )
  }

  public func getConnections() -> Future<String, [ConnectionDetails]> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0015).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> [ConnectionDetails] in
        return [ConnectionDetails].read(from: inp, using: &buf)
      }
    )
  }

  public func getLatestRelease(forArch arch: Symbol) -> Future<String, Release?> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0016).write(to: out)
        arch.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Release? in
        return Release?.read(from: inp, using: &buf)
      }
    )
  }

  public func getLicense() -> Future<String, String?> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0017).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> String? in
        return String?.read(from: inp, using: &buf)
      }
    )
  }

  public func getMetadata(forcingReload reload: Bool, inWorkspace id: UVarint) -> Future<String, Metadata> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0018).write(to: out)
        reload.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Metadata in
        return Metadata.read(from: inp, using: &buf)
      }
    )
  }

  public func getRecords(_ id: UVarint, withMaxBytes maxBytes: UVarint) -> Future<String, [IteratorResult]> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0019).write(to: out)
        id.write(to: out)
        maxBytes.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> [IteratorResult] in
        return [IteratorResult].read(from: inp, using: &buf)
      }
    )
  }

  public func getReleases(forArch arch: Symbol) -> Future<String, [Release]> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x001a).write(to: out)
        arch.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> [Release] in
        return [Release].read(from: inp, using: &buf)
      }
    )
  }

  public func getResourceConfigs(forResourceNamed name: String, resourceType type: Symbol, inWorkspace id: UVarint) -> Future<String, [ResourceConfig]> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x001b).write(to: out)
        name.write(to: out)
        type.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> [ResourceConfig] in
        return [ResourceConfig].read(from: inp, using: &buf)
      }
    )
  }

  public func getSchema(named name: String, inWorkspace id: UVarint) -> Future<String, Schema> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x001c).write(to: out)
        name.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Schema in
        return Schema.read(from: inp, using: &buf)
      }
    )
  }

  public func getSchemaRegistry(_ id: UVarint) -> Future<String, SchemaRegistry> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x001d).write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> SchemaRegistry in
        return SchemaRegistry.read(from: inp, using: &buf)
      }
    )
  }

  public func getScript(forTopic topic: String, inWorkspace id: UVarint) -> Future<String, String> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x001e).write(to: out)
        topic.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> String in
        return String.read(from: inp, using: &buf)
      }
    )
  }

  public func getTrialDeadline() -> Future<String, Varint> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x001f).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Varint in
        return Varint.read(from: inp, using: &buf)
      }
    )
  }

  public func installCallback(internalWithId id: UVarint, andAddr addr: Varint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0020).write(to: out)
        id.write(to: out)
        addr.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func isLicenseValid() -> Future<String, Bool> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0021).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Bool in
        return Bool.read(from: inp, using: &buf)
      }
    )
  }

  public func lex(_ code: String, using lexer: Lexer) -> Future<String, [Token]> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0022).write(to: out)
        code.write(to: out)
        lexer.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> [Token] in
        return [Token].read(from: inp, using: &buf)
      }
    )
  }

  public func openIterator(forTopic topic: String, andOffset offset: IteratorOffset, inWorkspace id: UVarint) -> Future<String, UVarint> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0023).write(to: out)
        topic.write(to: out)
        offset.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> UVarint in
        return UVarint.read(from: inp, using: &buf)
      }
    )
  }

  public func openWorkspace(withConn conn: ConnectionDetails, andPassword password: String?) -> Future<String, UVarint> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0024).write(to: out)
        conn.write(to: out)
        password.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> UVarint in
        return UVarint.read(from: inp, using: &buf)
      }
    )
  }

  public func ping() -> Future<String, String> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0025).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> String in
        return String.read(from: inp, using: &buf)
      }
    )
  }

  public func ppJson(_ code: String) -> Future<String, String> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0026).write(to: out)
        code.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> String in
        return String.read(from: inp, using: &buf)
      }
    )
  }

  public func publishRecord(toTopic topic: String, andPartition pid: UVarint, withKey key: Data?, andValue value: Data?, inWorkspace id: UVarint) -> Future<String, IteratorRecord> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0027).write(to: out)
        topic.write(to: out)
        pid.write(to: out)
        key.write(to: out)
        value.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> IteratorRecord in
        return IteratorRecord.read(from: inp, using: &buf)
      }
    )
  }

  public func resetIterator(withId id: UVarint, toOffset offset: IteratorOffset) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0028).write(to: out)
        id.write(to: out)
        offset.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func resetPartitionOffset(forGroupNamed groupId: String, andTopic topic: String, andPartitionId pid: UVarint, andTarget target: Symbol, andOffset offset: UVarint?, inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0029).write(to: out)
        groupId.write(to: out)
        topic.write(to: out)
        pid.write(to: out)
        target.write(to: out)
        offset.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func resetTopicOffsets(forGroupNamed groupId: String, andTopic topic: String, andTarget target: Symbol, inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x002a).write(to: out)
        groupId.write(to: out)
        topic.write(to: out)
        target.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func saveConnection(_ c: ConnectionDetails) -> Future<String, ConnectionDetails> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x002b).write(to: out)
        c.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> ConnectionDetails in
        return ConnectionDetails.read(from: inp, using: &buf)
      }
    )
  }

  public func saveSchemaRegistry(_ r: SchemaRegistry) -> Future<String, SchemaRegistry> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x002c).write(to: out)
        r.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> SchemaRegistry in
        return SchemaRegistry.read(from: inp, using: &buf)
      }
    )
  }

  public func startAutoUpdater(withFrequency frequency: UVarint?, andArch arch: Symbol, andVersion version: String) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x002d).write(to: out)
        frequency.write(to: out)
        arch.write(to: out)
        version.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func stopAutoUpdater() -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x002e).write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func touchConnection(_ c: ConnectionDetails) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x002f).write(to: out)
        c.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func updateConnection(_ c: ConnectionDetails) -> Future<String, ConnectionDetails> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0030).write(to: out)
        c.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> ConnectionDetails in
        return ConnectionDetails.read(from: inp, using: &buf)
      }
    )
  }

  public func updateResourceConfigs(_ configs: [String: String], forResourceNamed name: String, andResourceType type: Symbol, inWorkspace id: UVarint) -> Future<String, Void> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0031).write(to: out)
        configs.write(to: out)
        name.write(to: out)
        type.write(to: out)
        id.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> Void in }
    )
  }

  public func updateSchemaRegistry(_ r: SchemaRegistry) -> Future<String, SchemaRegistry> {
    return impl.send(
      writeProc: { (out: OutputPort) in
        UVarint(0x0032).write(to: out)
        r.write(to: out)
      },
      readProc: { (inp: InputPort, buf: inout Data) -> SchemaRegistry in
        return SchemaRegistry.read(from: inp, using: &buf)
      }
    )
  }

  public func installCallback(announceUpdate proc: @escaping (String, Release) -> Void) -> Future<String, Void> {
    return NoiseBackend.installCallback(id: 0, rpc: self.installCallback(internalWithId:andAddr:)) { inp in
      var buf = Data(count: 8*1024)
      proc(
        String.read(from: inp, using: &buf),
        Release.read(from: inp, using: &buf)
      )
    }
  }
}
